% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getVarValues.R
\name{getVarValues}
\alias{getVarValues}
\title{[~] Parse arguments of a function and return approriate values for selected variable}
\usage{
getVarValues(VAR, DATA, CALL = match.call(definition =
  sys.function(sys.parent()), call = sys.call(sys.parent())),
  env = parent.frame(2L))
}
\arguments{
\item{VAR}{A name of a variable (with or without quotes).}

\item{DATA}{A name of a data frame (with or without quotes).}

\item{CALL}{(\code{\link[=call-class]{Call}}) to be parsed. Default is
call to parent function.}

\item{env}{The environment in which expressions must be evaluated.}
}
\value{
A vector. If possible, return \code{DATA[,VAR]}.
Otherwise return \code{VAR}.
}
\description{
Parse dataframe \code{DATA}, variable \code{VAR} and a call
\code{CALL} of a function and return approriate values of the
\code{VAR}. \cr If possible, return \code{DATA[,"VAR"]} \cr
Otherwise return \code{VAR}.
}
\examples{

library(spMisc)
# --------------------------------------------------------------------
# [Behaviour of function has changed] EXAMPLES  are out of date!!!
# --------------------------------------------------------------------


# EXAMPLE 1 *****************************************************************

# Clear current environment
clear()

# Data
df  <- mtcars[,c("cyl","gear")]

#  Function, that uses `getVarValues`:
f1 <- function(data, v1, v2) { getVarValues(v1, data) }

# Returns values of `df$cyl`:
f1(df, "cyl")
##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4

# Values of `df$gear` not of `df$cyl`:
cyl <- "gear"
f1(df, cyl)
##  [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4

# Returns values of `df$gear`:
f1(df, "gear")
##  [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4

var <- c("My", "variable", "var")
f1(df, var)
## [1] "My"   "variable"   "var"
## Warning message:
## In getVarValues(v1, data) : Arguments 'DATA' and 'VAR' do not match!!!

# EXAMPLE 2 *****************************************************************
# A Data frame
   df <- data.frame(A = "Values_A_(DATA.FRAME)",
                    E = "Values_E_(DATA.FRAME)", stringsAsFactors = FALSE)

# Vectors
   A <- "Values of the vector 'A'"
   B <- "Values of the vector 'B'"


# A call object `CALL`:

fun  <- function(data, gr, ID) match.call()
CALL <- fun(df, A, B)
CALL
## fun(data = df, gr = A, ID = B)


# Outputs of `getVarValues` -------------------------------------------------


getVarValues("A", df, CALL)
## [1] "Values_A_(DATA.FRAME)"

getVarValues(A, df)
## [1] "Values of the vector 'A'"

getVarValues(B, df)
## [1] "Values of the vector 'B'"

# UNEXPECTED results -----------------------------------------------------------------------

\donttest{
\dontrun{

 getVarValues(ID, df) # ??? `ID` found only in function's `fun` definition.
 ## NULL

 getVarValues(G, df) # ERROR, as variable G does not exist.
 ##  Error in eval(expr, envir, enclos) : object 'G' not found

 getVarValues(F, df) # F is a special variable: F = FALSE
 ##  FALSE

 getVarValues(c, df) # c() is a function.
 ## function (..., recursive = FALSE)  .Primitive("c")
}}
}
\author{
Vilmantas Gegzna
}

